# 모던 자바스크립트 24~26장

# 24장 클로저

---

<aside>
✍🏼 클로저란 ? : 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

</aside>

```jsx
const x = 1;
function outerFunc() {
  const x = 10;
  function inerFunc() {
    console.log(x); //결과 10;
  }
  inerFunc();
}
outerFunc();
```

자바스크립트는 함수를 **어디에서 정의**했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프라고 한다.

위 예제를 보면 함수가 중첩되어 있다. 따라서 inerFunc의 상위 스코프는 전역이 아닌 outerFunc이다. 

함수가 어디서 정의했는가는 함수 내부슬롯 `[[Environment]]`에 상위 스코프의 참조를 저장한다 → 상위 스코프를 기억한다.

예제를 살펴보겠다.

```jsx
//1번 함수 내부에 정의된 함수
const x = 1;
function outerFunc() {
  const x = 10;
//자신의 정의된 환경 = outerFunc, [[Environment]]엔 상위스코프인 outerFunc가 들어감
  function inerFunc() { 
    console.log(x); 
  }
  inerFunc();
}
outerFunc();

//함수 외부, 전역에서 정의된 함수
const x = 1;
function foo() {
  const x = 10;
  bar();
}
//실행은 foo안에서 했지만 관계없고 정의된 환경인 전역렉시컬 환경의 참조가 저장된다.
function bar() { 
  console.log(x);
}
foo();
bar();
```

### 클로저 : 부활

```jsx
const x = 1;
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner; //outer 함수의 생명주기 마감, 소유한 지역변수 또한 소멸
}
const innerFunc = outer();
innerFunc(); //10;
```

외부함수보다 중첩함수가 더 오래 유지되는 경우 중첩함수는 생명주기가 종료된 외부함수의 변수를 참조할 수 있다. 이것이 **클로저**이다.

이것이 가능한 이유

- inner 함수가 평가되는 시점에 상위 스코프인 outer 함수의 렉시컬 환경을 `[[Environment]]` 에 저장한다.
- outer 함수의 생명주기가 종료되고 실행컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸되진 않는다.
    - 그 이유는 가비지컬렉터는 누군가 참조하고 있는 메모리 공간을 해체하지 않기 때문이다.
- inner 함수가 호출되었을 때 `[[Environment]` 안의 값인 outer 함수의 렉시컬 환경을 이용하므로 상위 스코프의 식별자를 기억해 낼 수 있다.

### 클로저의 조건

- 중첩된 함수가 상위 스코프의 식별자를 참조해야한다.
    - 참조하는 식별자를 자유변수라고 한다. 브라우저는 자유변수만을 기억한다.
- 중첩된 함수가 외부로 반환되지 않아 외부 함수보다 일찍소멸하면 클로저가 아니다.

> **결론 : 클로저는 중첩함수가 상위 스코프의 식별자를 참조하고 잇고 중첩함수가 외부 함수보다 더 오래 유지되는 경우에 한정된다.**
> 
> 
> 클로저의 다른 의미 : 자유변수에 묶여있는 함수다.
> 

### 클로저의 용도

- **상태를 안전하게 변경하고 유지하기 위해 사용한다.**

특정 함수에게만 상태변경을 허용할 수 있음

카운터를 구현하는 코드로 예시를 들어보겠다.

```jsx
let num = 0; //전역변수
const increase = function () {
  return ++num;
};
console.log(increase());
console.log(increase());
console.log(increase());
```

전역변수를 통해 카운트 상태를 관리하므로 수정될 가능성이 크다. 

아래와 같이 클로저를 사용하면 예방할 수 있다.

```jsx
let increase = (function () { //즉시실행함수 사용, 반환된 함수가 increase 변수에 저장
  let num = 0;
  return function () { //즉시실행함수의 렉시컬 환경을 기억
    return ++num;
  };
})();
console.log(increase());
console.log(increase());
console.log(increase());
```

즉시실행 함수는 실행즉시 소멸되지만 클로저를 사용하면 즉시 실행함수의 렉시컬 환경을 참조할 수 있다.

**따라서 increase를 통해서만 num 값을 증가시킬 수 있다.**

- 캡슐화와 정보은닉에 사용된다.

캡슐화 : 객체의 프로퍼티와 메서드를 묶는 것의 의미와 특정 프로퍼티와 메서드를 감추는 정보은닉의 의미가 있다.

객체에서 캡슐화는 프로퍼티로 생성시 모두가 사용가능하고 지역변수로써 선언시 은닉이 가능하다.

# 25장 클래스

---

**클래스는 프로토타입의 문법적 설탕인가?**

원래의 자바스크립트는 클래스문법 없이 객체지향언어로써 상속이 구현 가능했다.

es6가 도입 후 생겨난 새로운 문법으로 생성자 함수와 비슷한 점이 있지만 몇가지 차이가 있다.

### 클래스만이 가지고 있는 특성

1. 클래스를 new 연산자 없이 호출하면 에러 발생 - 붕어빵틀을 먹을 순 없음
2. expend와 super 문법 지원
3. 호이스팅이 발생하지 않는 것처럼 동작
4. 암묵적인 strict mode 적용
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enmerable]]의 값이 false이다.
6. function 키워드를 생략한 메서드 축약표현 사용

결론 : 객체 생성 방식이 명확하고 상속관계가 명료한 새로운 객체 생성 메커니즘이다.

### 클래스

클래스의 이름은 **파스칼 케이스**를 사용한다.

클래스는 **일급 객체**이다. 

> 일급 객체의 특성
> 
> 
> 변수나 자료구조에 저장할 수 있다.
> 
> 무명의 리터럴로 생성할 수 있다.
> 
> 함수의 매개변수에 전달 가능
> 
> 함수의 반환값으로 사용가능
> 

클래스도 **함수**이다 ⇒ 함수 객체 고유의 프로퍼티를 모두 가지고 있다.

(프로토타입과 연결, 자신의 스코프체인을 구성)

클래스는 constructor(생성자), 프로토타입 메서드, 정적 메서드 3가지로 정의할 수 있다.

- **constructor**는 인스턴스를 생성하고 초기화하는 특수한 메서드이다.
    - [this.name](http://this.name) = name 과 같은 형식으로 초기화하며 this는 클래스가 생성한 인스턴스를 가리킨다.
    - 인스턴스로 만들어지면 constructor은 메서드로 해석되는 것이 아닌 코드의 일부가 된다.
    - constructor은 한개만 존재가능하고 생략가능하다.
        - 생략시 빈 constructor가 암묵적으로 생성됨
    
    ```jsx
    class Person {
    ........
    //생성자
    	constructor(name){ //매개변수가 전달된다.
    	this.name = name; //new 연산자로 호출하면 암묵적으로 this를 반환한다.
    	} 
    }
    let 유순상 = new Person("유순상"); //매개변수가 전달된다.
    ```
    
- 프로토타입 메서드는 클레스 몸체에서 정의한 메서드이다.
    - 프로토타입 메서드로 정의하면 인스턴스의 프로토타입에 존재하는 프로토 타입 메서드가 된다.
    
    ```jsx
    class Person {
    ...
    //프로토타입 메서드
    	sayhi(){
    	console.log(this.name);
    	}
    ```
    
- 정적메서드 : 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
    - 메서드에 static 키워드를 붙여 생성한다.
    - 클래스에 바인딩된 메서드이며 인스턴스로 클래스의 메서드를 상속받을 수 없음
    
    ```jsx
    class Person {
    ......
    //정적메서드
    	static sayHello(){
    
    	}
    }
    Person.sayHello()//실행
    ```
    

> 프로토타입 메서드와 정적메서드의 차이
> 
> 1. 프로토타입 체인의 차이
> 2. 정적 메서드는 클래스로 호출 vs 프로토타입 메서드는 인스턴스로 호출
> 3. 정적 메서드는 **인스턴스 프로퍼티 참조 불가**

<aside>
<img src="https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1580888106/noticon/owcvyw4dggdylen2ql5w.gif" alt="https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1580888106/noticon/owcvyw4dggdylen2ql5w.gif" width="40px" /> 한마디로 this를 사용하면 프로토타입 아니라면 정적 메서드를 상용하자.

</aside>

```jsx
class Person {
//여러변수 선언 가능
x=10;

//생성자
	constructor(name){
	this.name = name;
	} 
//프로토타입 메서드
	sayhi(){
	console.log(this.name);
	}
//정적메서드
	static sayHello(){

	}
}
const me = new Person("lee")
```

클래스도 호이스팅이 발생한다. 하지만 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

### 인스턴스 생성방법

```jsx
class Person {}
const me = new Person();
```

클래스의 인스턴스 생성은 반드시 new 연산자와 함께 호출되어 생성된다.

### 인스턴스 생성 과정

1. new 연산자와 함께 클래스 호출
2. 암묵적으로 빈 객체 생성
3. 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다.
4. 빈 객체는 this에 바인딩되며 constructor 내부의 this 클래스가 생성한 인스턴스를 가리킨다.
5. constructor 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.
6. 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환한다.

### 접근자 프로퍼티

자체적인 값을 가지고있지 않고 다른 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수이다.

getter와 setter로 구성되어 있다.

메서드 이름 앞에 키워드를 붙여 정의하며 get, set으로 나뉜다.

get은 인스턴스 프로퍼티에 접근할 때마다 값을 조작하거나 별도의 행위가 필요할 때 사용된다, 무언가를 취득할때 사용하므로 반환인 return이 필수

set은 인스턴스 프로퍼티에 값을 할당할 때마다 값을 조작하거나 별도의 행위가 필요할 때 사용된다, 무언가를 할당할 때 사용하므로 하나의 매개변수 필수

### 클래스 필드

클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어

최신문법이므로 추후에 재학습 바람

### 상속에 의한 클래스 확장

기존의 클래스를 상속받아 고유의 특성을 추가해 확장하는 것이다.

코드 재사용 관점에서 유용하다.

extends키워드

```jsx
class 자식 extends 부모 {}
```

프로토타입 메서드, 정적 메서드모두 상속이 가능하다.

extends 키워드 다음에는 클래스 뿐만 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 표현식을 사용할 수 있다.

예를 들어 extends 뒤에 삼항연산자 조건식을 두어 참일 때, 거짓일 때 다르게 상속받을 수 있다.

서브클래스에서 constructor를  생략하면 클래스에 다음과 같은 constructor가 정의된다. args는 new연산자와함께 클래스를 호출할때 전달한 리스트이다.

super는 부모 클래스의 constructor를 호출하여 인스턴스를 생성한다.

super

함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 키워드이다. 

- super 호출시 수퍼클래스의 constructor를 호출
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

서브클래스에서 constructor를 생략하지 않는다면 super는 꼭 호출해줘야한다. 그 이전에는 this를 참조할 수 없음

메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

팁 : 클래스 또는 생성자함수를 이용해 정적 메서드를 모아두면 유용하게 사용할 수 있다.

# 14장

---