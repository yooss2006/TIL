# 클래스

**클래스는 프로토타입의 문법적 설탕인가?**

이전의 자바스크립트는 클래스 문법 없이 객체지향언어로써 생성자 함수와 같은 문법으로 상속이 구현 가능했다.

클래스는 es6가 도입 후 생겨난 새로운 문법으로 생성자 함수와 비슷한 점이 있지만 몇 가지 차이가 있다.

### 클래스만이 가지고 있는 특성

1. 클래스를 new 연산자 없이 호출하면 에러 발생
   - 붕어빵틀을 먹을 순 없음
2. extend와 super 문법 지원
3. 호이스팅이 발생하지 않는 것처럼 동작
4. 암묵적인 strict mode 적용
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enmerable]]의 값이 false이다.
   - 열거할 수 없음
6. function 키워드를 생략한 메서드 축약표현 사용

결론 : 객체 생성 방식이 명확하고 상속관계가 명료한 새로운 객체 생성 메커니즘이다.

</br>

## 클래스

### 클래스의 형식

클래스는 constructor(생성자), 프로토타입 메서드, 정적 메서드 3가지로 정의할 수 있다.

```
class Person {
    constructor();
    method1();
    static method2();
}

let 김철수 = new Person();
```

- 클래스의 이름은 **파스칼 케이스**를 사용한다.
- 대문자로 시작하며 단어의 첫글자를 대문자로 시작한다.

- 클래스는 **일급 객체**이다.

> **일급 객체**의 특성
>
> 변수나 자료구조에 저장할 수 있다.
>
> 무명의 리터럴로 생성할 수 있다.
>
> 함수의 매개변수에 전달 가능
>
> 함수의 반환값으로 사용가능

- 클래스도 **함수**이다 ⇒ 함수 객체 고유의 프로퍼티를 모두 가지고 있다.

  - 프로토타입과 연결, 자신의 스코프체인을 구성

</br>

### constructor

인스턴스를 생성하고 초기화하는 특수한 메서드이다.

- this.name = name 과 같은 형식으로 초기화하며 this는 클래스가 생성한 인스턴스를 가리킨다.
- 인스턴스로 만들어지면 constructor은 메서드로 해석되는 것이 아닌 코드의 일부가 된다.
- constructor은 한개만 존재가능하고 생략가능하다.
  - 생략시 빈 constructor가 암묵적으로 생성됨

```jsx
class Person {
........
//생성자
	constructor(name){ //2. 매개변수가 전달된다.
	this.name = name; //3. new 연산자로 호출하면 암묵적으로 this를 반환한다.
	}
}
let 유순상 = new Person("유순상"); //1. 매개변수를 전달한다.
```

### 프로토타입 메서드

프로토타입 메서드는 클레스 몸체에서 정의한 메서드이다.

- 프로토타입 메서드로 정의하면 인스턴스의 프로토타입에 존재하는 프로토 타입 메서드가 된다.

```jsx
class Person {
...
//프로토타입 메서드
	sayhi(){
	console.log(this.name);
	}
```

### 정적메서드

정적메서드 : 인스턴스를 생성하지 않아도 호출할 수 있는 메서드

- 메서드에 static 키워드를 붙여 생성한다.
- 클래스에 바인딩된 메서드이며 인스턴스로 클래스의 메서드를 상속받을 수 없음

```jsx
class Person {
......
//정적메서드
	static sayHello(){

	}
}
Person.sayHello()//인스턴스를 만들지 않아도 실행 가능하다.
```

> **프로토타입 메서드와 정적메서드의 차이**
>
> 1. 프로토타입 체인의 차이
> 2. 정적 메서드는 클래스로 호출 vs 프로토타입 메서드는 인스턴스로 호출
> 3. 정적 메서드는 **인스턴스 프로퍼티 참조 불가**

<aside>
<img src="https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1580888106/noticon/owcvyw4dggdylen2ql5w.gif" alt="https://noticon-static.tammolo.com/dgggcrkxq/image/upload/v1580888106/noticon/owcvyw4dggdylen2ql5w.gif" width="40px" /> 한마디로 this를 사용하면 프로토타입 아니라면 정적 메서드를 사용하자.

</aside>
</br>

클래스도 호이스팅이 발생한다. 하지만 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

</br>

### 클래스의 인스턴스 생성방법

```jsx
class Person {}
const me = new Person();
```

클래스의 인스턴스 생성은 반드시 **new 연산자**와 함께 호출되어 생성된다.

</br>

### 인스턴스 생성 과정

1. new 연산자와 함께 클래스 호출
2. 암묵적으로 빈 객체 생성
3. 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다.
4. 빈 객체는 this에 바인딩되며 constructor 내부의 this 클래스가 생성한 인스턴스를 가리킨다.
5. constructor 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.
6. 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환한다.

</br>

### 접근자 프로퍼티

자체적인 값을 가지고있지 않고 다른 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수이다.

getter와 setter로 구성되어 있다.

메서드 이름 앞에 키워드를 붙여 정의하며 get, set으로 나뉜다.

- get은 인스턴스 프로퍼티에 접근할 때마다 값을 조작하거나 별도의 행위가 필요할 때 사용된다.

  - 무언가를 취득할때 사용하므로 반환인 return이 필수

- set은 인스턴스 프로퍼티에 값을 할당할 때마다 값을 조작하거나 별도의 행위가 필요할 때 사용된다.
  - 무언가를 할당할 때 사용하므로 하나의 매개변수 필수

</br>

### 클래스 필드

js의 최신문법

어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.

프로퍼티 = 값으로 간단히 만들 수 있으며 프로토타입이 아닌 개별 인스턴스에만 클래스 필드가 설정된다는 특징이 있다.

인스턴스 정의시 외부 초기값을 필요로 한다면 constructor 방법 그외는 두가지 방법을 골라 사용하면 된다.

#### private 알아보기

자바스크립트는 접근제어자를 지원하지않아 언제나 public이었다.
새롭게 생겨난 #을 이용한 private 문법은 클래스 필드에 작성한다.

```
#name = "jam"
```

private는 클래스 내부에서만 참조가 가능하고 자식클래스 내부, 인스턴스를 통한 접근 모든 것을 막는다.

</br>

### 상속에 의한 클래스 확장

기존의 클래스를 상속받아 고유의 특성을 추가해 확장하는 것이다.

코드 재사용 관점에서 유용하다.

기존의 생성자함수를 이용한 인스턴스 생성보다 직관적인 생성이 가능하다.

#### extends키워드

```jsx
class 자식 extends 부모 {}
```

프로토타입 메서드, 정적 메서드모두 상속이 가능하다.

#### 동적 상속 기능

extends 키워드 다음에는 클래스 뿐만 아니라 생성자 함수, [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 표현식을 사용할 수 있다.

- extends 뒤에 삼항연산자 조건식을 두어 참일 때, 거짓일 때 다르게 상속받을 수 있다.

서브클래스에서 constructor를 생략하면 부모클래스의 constructor를 호출하여 인스턴스를 생성한다.

#### super키워드

함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 키워드이다.

- super 호출시 수퍼클래스의 constructor를 호출
- super를 참조하면 수퍼클래스의 메서드를 호출 가능

서브클래스에서 constructor를 생략하지 않는다면 super는 꼭 호출해줘야한다.

- super가 없다면 인스턴스를 만들 수 없어 에러가 발생한다.

메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

팁 : 클래스 또는 생성자함수를 이용해 정적 메서드를 모아두면 유용하게 사용할 수 있다.
