# pipe

pipe는 함수들을 **합성한 함수를 반환하는 기능**을 수행합니다.
go와 비슷하지만 다른 점이 있습니다.

- go는 인자로 받은 함수를 모두 실행해 **값을 반환**합니다.
- pipe는 값이 아닌 **함수**를 반환합니다.

**pipe**는 아래처럼 사용되게 됩니다.

```javascript
const f = pipe(
  //0이 들어옴
  (a) => a + 1, //1
  (a) => a + 10, //11
  (a) => a + 100 //111
); //f는 함수 자체가 된다.

log(f(0));
```

**pipe**를 만드는 방법은 다음과 같습니다.

```jsx
const pipe =
  (...fs) =>
  (a) =>
    go(a, ...fs);
```

이렇게 보면 해석하기 어려운데 자세하게 풀어보면

`const pipe = (...fs) => {}` : 함수들이 fs에 인자로 들어갑니다.

```jsx
//이것들이요!
(a) => a + 1, (a) => a + 10, (a) => a + 100;
```

`const pipe = (...fs) => (a) => {}` : a를 매개변수로 받는 함수를 반환합니다.

f가 함수를 반환하기 때문에`f(0)`이런 구조가 가능해집니다.

<br/>

`const pipe = (...fs) => (a) => go(a, ...fs)` : `go()`로 결과 값을 반환합니다.

a가 go의 초기값 부분으로 들어가 연산 후 결과를 반환합니다.

<br/>

## 업그레이드 버전

---

```jsx
const upf = pipe(
  (a, b) => a + b,
  (a) => a + 10,
  (a) => a + 100
);

log(f(0, 1));
```

위에서 만든 pipe 함수는 2개 이상의 인수를 받는 `(a, b) => a + b`와 같은 함수가 내부에 있을 경우 동작하지 않습니다.
**2개 이상의 인자를 받는 함수**도 허용하는 포괄적인 pipe 함수를 만들어 보겠습니다.

```jsx
const pipe =
  (f, ...fs) =>
  (...as) =>
    go(f(...as), ...fs);
```

`const pipe = (f, ...fs) => {}`
`(f,...fs)`처럼 나누는 이유는 두 개 이상의 인자를 사용하는 함수만 분리하기 위함입니다.

따라서 f에는 `(a, b) => a + b` fs에는 나머지 함수가 들어갑니다.

<br/>

`const pipe = (f, ...fs) => (...as) => {}`
pipe는 함수를 반환하는데 이 함수는 인수 여러 개를 받습니다. `f(0, 1)`처럼 말이지요

<br/>

`const pipe = (f, ...fs) => (...as) => go(f(...as), ...fs)`

`...as`는 `f()`에 들어가고 go에서 초기값으로 사용될 값을 반환합니다.

즉 a,b가 더해진 값 1이 `go(1, ...fs)`에 오게 됩니다.
