# go

함수를 중첩해서 사용하는 경우 개발자의 입장에서 함수가 어떤 식으로 진행되는 지 파악하기가 쉽지 않습니다.

```javascript
//우엑 🤢
console.log(
  reduce(
    add,
    map(
      (p) => p.price,
      filter((p) => p.price < 20000, products)
    )
  )
);
```

위 함수는 products 배열에서 객체의 price가 20000 이하의 금액인 객체만 추리고 값만 골라서 모두 더한 값을 콘솔 메시지로 출력하는 함수입니다.

이런 함수를 파악하려면 가장 안쪽에 중첩된 함수부터 바깥으로 나오면서 의미를 파악해야 합니다.(난감하죠...)

go를 사용하면 함수가 어떤 과정을 거치는지 순서대로 파악이 가능합니다.

```javascript
//굿 😃
go(
  products,
  (products) => filter((p) => p.price < 20000, products),
  (products) => map((p) => p.price, products),
  (prices) => reduce(add, prices),
  log
);
```

> **go**는 첫 번째 인자로 시작하는 값을 넣고 나머지 인자로 함수를 받습니다.
> 함수의 반환 값을 다음 함수로 넘기면서 차례대로 함수를 실행합니다.

말로 들으면 어려워서 예시를 들며 설명하겠습니다.

```javascript
go(
  0,
  (a) => a + 1,
  (a) => a + 10,
  console.log
);
```

위 go 함수는 첫 번째 인자로 시작하는 값 즉 0을 받습니다.
0은 다음 인자인 `a => a + 1`의 인자로 들어가며 1을 반환합니다.
1은 다음 인자인 `a => a + 10`의 인자로 들어가며 11을 반환합니다.
이처럼 go가 어떤 기능을 하는지만 이해한다면 더 직관적으로 함수의 진행을 확인할 수 있습니다.

go 함수는 그럼 어떻게 만들까요?
go 함수는 reduce 함수를 기반으로 만들 수 있습니다.

```javascript
//go 만드는 방법
const go = (...args) => reduce((a, f) => f(a), args);
```

1. go에 인수를 넣고 `...args`처럼 나머지 매개변수를 이용하면 args는 함수 내에서 배열로 사용할 수 있습니다.
   ex) `[0, a=>a+1, a=>a+10]`

2. reduce함수에 의해 args에서 요소를 하나씩 꺼내고 `(a, f) => f(a)` 함수의 인자로 들어가게 됩니다.
   ex) `(0, a=>a+1) => (a=>a+1)(0)` 즉 `=>a+1` 함수에 0이 인수로 들어가고 결과적으로 1을 반환합니다.

3. 1과 arg의 다음 요소가 위와 같은 연산을 반복합니다.
   ex) `(1, a=>a+10) => (a=>a+10)(1)` 결과로 11 반환
